# Story 2.3: Poll Expiration System

## Status
Ready for Development

## Story
**As a** user,
**I want** my polls to automatically close after 24 hours,
**so that** decisions are made within a reasonable timeframe.

## Acceptance Criteria
1. Poll expiration is set to 24 hours from creation time
2. Automatic poll closure system is implemented
3. Poll status is tracked (active, closed, deleted)
4. Expired polls are marked as closed in the database
5. Visual indicators show poll expiration status
6. Countdown timer displays remaining time for active polls
7. Closed polls display final results and cannot accept new votes

## Tasks / Subtasks
- [ ] Task 1: Database Schema Updates (AC: 3, 4)
  - [ ] Add status field to polls table
  - [ ] Add expires_at timestamp field
  - [ ] Create database indexes for efficient querying
  - [ ] Update existing polls service functions
- [ ] Task 2: Poll Expiration Logic (AC: 1, 2)
  - [ ] Implement automatic poll closure system
  - [ ] Create background job for checking expired polls
  - [ ] Update poll status when expiration time is reached
  - [ ] Handle edge cases and error scenarios
- [ ] Task 3: Visual Indicators (AC: 5, 6)
  - [ ] Create countdown timer component
  - [ ] Implement poll status badges
  - [ ] Add expiration warnings for polls nearing closure
  - [ ] Design mobile-optimized status indicators
- [ ] Task 4: Poll Status Management (AC: 7)
  - [ ] Prevent voting on closed polls
  - [ ] Display final results for closed polls
  - [ ] Update poll viewing interface for different statuses
  - [ ] Handle poll deletion and cleanup
- [ ] Task 5: Testing (AC: All)
  - [ ] Test automatic expiration system
  - [ ] Test visual indicators and countdown timers
  - [ ] Test poll status transitions
  - [ ] Test edge cases and error handling

## Dev Notes

### Previous Story Insights
This story builds on Story 2.2 (Poll Creation Form) which establishes poll creation functionality. The expiration system will integrate with the existing poll creation flow and database schema, ensuring polls are automatically managed throughout their lifecycle.

### Technology Stack
[Source: architecture.md#tech-stack]
- **Database**: Supabase with PostgreSQL for poll status tracking
- **Background Jobs**: Supabase Edge Functions for automatic expiration
- **Real-time**: Supabase Realtime for live status updates
- **UI Components**: Shadcn/ui components for status indicators
- **Mobile Design**: Tailwind CSS with mobile-first approach

### Integration Points
[Source: architecture.md#unified-project-structure]
- **Database**: Extends existing polls table with status and expiration fields
- **Poll Creation**: Integrates with poll creation flow from Story 2.2
- **Voting System**: Prevents voting on expired polls (prepares for Story 3.2)
- **UI Components**: Uses existing components from Story 1.4
- **Real-time Updates**: Leverages Supabase Realtime for live status updates

### File Structure
[Source: architecture.md#unified-project-structure]
```
src/
├── components/
│   ├── poll/
│   │   ├── PollStatusBadge.tsx
│   │   ├── CountdownTimer.tsx
│   │   └── ExpirationWarning.tsx
│   └── ui/
│       └── (existing components)
├── lib/
│   ├── services/
│   │   ├── polls.ts (existing, updated)
│   │   └── expiration.ts
│   └── utils/
│       └── time-helpers.ts
└── supabase/
    └── functions/
        └── check-expired-polls/
            └── index.ts
```

### Technical Implementation
[Source: technical-specifications.md#poll-expiration-system]

#### Database Schema Updates
```sql
-- Add status and expiration fields to polls table
ALTER TABLE polls ADD COLUMN status VARCHAR(20) DEFAULT 'active';
ALTER TABLE polls ADD COLUMN expires_at TIMESTAMP WITH TIME ZONE;

-- Create index for efficient expiration queries
CREATE INDEX idx_polls_expires_at ON polls(expires_at) WHERE status = 'active';

-- Update existing polls to set expiration
UPDATE polls SET expires_at = created_at + INTERVAL '24 hours' WHERE expires_at IS NULL;
```

#### Poll Status Management
```typescript
// lib/services/expiration.ts
export const checkAndUpdateExpiredPolls = async (): Promise<void> => {
  const supabase = createClient();
  const now = new Date();
  
  const { data, error } = await supabase
    .from('polls')
    .update({ status: 'closed' })
    .lt('expires_at', now.toISOString())
    .eq('status', 'active');
    
  if (error) throw error;
};

export const getPollStatus = (poll: Poll): PollStatus => {
  if (poll.status === 'closed' || poll.status === 'deleted') {
    return poll.status;
  }
  
  const now = new Date();
  const expiresAt = new Date(poll.expires_at);
  
  if (now >= expiresAt) {
    return 'closed';
  }
  
  return 'active';
};
```

#### Countdown Timer Component
```typescript
// components/poll/CountdownTimer.tsx
interface CountdownTimerProps {
  expiresAt: string;
  onExpire?: () => void;
}

export default function CountdownTimer({ expiresAt, onExpire }: CountdownTimerProps) {
  const [timeLeft, setTimeLeft] = useState<TimeLeft | null>(null);
  
  useEffect(() => {
    const timer = setInterval(() => {
      const now = new Date();
      const expiration = new Date(expiresAt);
      const diff = expiration.getTime() - now.getTime();
      
      if (diff <= 0) {
        setTimeLeft(null);
        onExpire?.();
        clearInterval(timer);
        return;
      }
      
      setTimeLeft(calculateTimeLeft(diff));
    }, 1000);
    
    return () => clearInterval(timer);
  }, [expiresAt, onExpire]);
  
  // Component implementation
}
```

#### Background Job Implementation
```typescript
// supabase/functions/check-expired-polls/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

serve(async (req) => {
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );
  
  const { data, error } = await supabase
    .from('polls')
    .update({ status: 'closed' })
    .lt('expires_at', new Date().toISOString())
    .eq('status', 'active');
    
  if (error) {
    return new Response(JSON.stringify({ error: error.message }), { status: 500 });
  }
  
  return new Response(JSON.stringify({ updated: data?.length || 0 }), { status: 200 });
});
```

### File Locations
[Source: architecture.md#unified-project-structure]
- **Status Components**: `apps/web/src/components/poll/`
- **Expiration Logic**: `apps/web/src/lib/services/expiration.ts`
- **Background Jobs**: `apps/web/supabase/functions/`
- **Database Migrations**: `apps/web/supabase/migrations/`

### Technical Constraints
[Source: architecture.md#technical-assumptions]
- **Expiration Time**: Exactly 24 hours from creation time
- **Status Tracking**: Active, closed, deleted statuses
- **Background Jobs**: Supabase Edge Functions for automatic processing
- **Real-time Updates**: Live status updates via Supabase Realtime
- **Mobile Performance**: Efficient countdown timer updates
- **Database**: Optimized queries for expiration checking

### Testing
[Source: architecture.md#testing-strategy]

#### Testing Standards
- **Test File Location**: `apps/web/tests/unit/` for unit tests
- **Testing Framework**: Vitest + React Testing Library for component testing
- **Test Standards**: 
  - Unit tests for expiration logic and components
  - Integration tests for database operations
  - E2E tests for complete expiration flow
- **Testing Requirements for this Story**:
  - Test automatic expiration system
  - Test countdown timer accuracy
  - Test poll status transitions
  - Test edge cases and error handling

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-27 | 1.0 | Initial story creation using BMAD workflow | Product Manager |

## Dev Agent Record

### Agent Model Used
*To be populated by Dev Agent*

### Debug Log References
*To be populated by Dev Agent*

### Completion Notes List
*To be populated by Dev Agent*

### File List

**New Files:**
*To be populated by Dev Agent*

**Modified Files:**
*To be populated by Dev Agent*

**Database Migrations:**
*To be populated by Dev Agent*

## QA Results
*This section will be populated by the QA agent after implementation review*
